<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
  <script>
    // function Construct(name, age) {
    //   console.log(this)
    //   this.name = name;
    //   // 实例成员
    //   this.age = age;
    // }
    
    // 因为新增引用数据类型需要在堆开辟一个内存空间，如果每次实例化的话，就会导致内存空间的浪费，所以将所有的引用数据类型放入构造函数的共享属性中
    // Construct.prototype.sing = function () {
    //   console.log(this.name, this.age)
    // }
    //
    //
    // const constr = new Construct("a", 1);
    // constr.sing()

    // 静态成员
    // Construct.gender = "man";
    // console.log(Construct.gender)

    // 在对象中不能调用，是属于构造函数单独的
    // console.log(constr.gender)

    // console.log(constr, 'constr')
    
    
    // function Star(a, b) {
    //   this.a = a;
    //   this.b = b;
    //   this.c = 'c'
    //   let e = '3'
    // }
    //
    // Star.d = 'd'
    //
    // let s = new Star(1, 2);
    
    // console.log(Star.prototype, 'Star')
    // console.log(s.__proto__, 's')
    //
    // console.log(Star.prototype === s.__proto__, '===')
    
    /*-------------------------------------------------------------------------------------------------------------------*/
    
    // 类型： 类型对象
    function Person(name, age) {    // 构造函数 类型
      this.name = name;
      this.age = age;
    }

    // 实例： 实例对象
    let p = new Person('tom', 12) // 根据类型创建的实例对象
    
    // undefined 和 null 的区别
    /*
    * undefined 是声明了变量但是没有定义
    * null 是一个对象的地址赋值为空
    * */
    
    // null在什么时候使用
    /*
    * 开始时，赋值给对象代表空地址
    * 结束时，赋值给对象，使变量所指的地址为空，让对象称为垃圾，被对象回收机制回收
    *
    * */
    
    /*
    * 数据类型
    * 基本类型
    * 对象类型
    *
    * 变量类型  js是在运行时判断变量类型的，所以检测的是值类型
    * 基本类型： 保存的是基本类型的数据
    * 引用类型： 保存的是对象的地址值
    *
    *
    * */
    
    
    
    
  </script>
</body>
</html>
